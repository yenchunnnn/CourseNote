# Intermediate SQL

## Selecting Data

### Querying a database

**Setup films database**

```{r}
# Creating a new database
# Connect to the default postgres database
library(DBI)
con <- dbConnect(RSQLite::SQLite(), "")
knitr::opts_chunk$set(connection = "con")

# Loading data
films <- read.csv("data/films.csv", header = FALSE, na.strings = "")
colnames(films) <- c("id", "title", "release_year", "country", "duration", "language", "certification", "gross", "budget")

people <- read.csv("data/people.csv", header = FALSE, col.names = c("id", "name", "birthdate", "deathdate"), na.strings = "") 

reviews <- read.csv("data/reviews.csv", header = FALSE, col.names = c("id", "film_id","num_user", "num_critic", "imdb_score", "num_votes", "facebook_likes"), na.strings = "")

roles <- read.csv("data/roles.csv", header = FALSE, col.names = c("id", "film_id", "person_id", "role"), na.strings = "")

# Create database tables
dbWriteTable(con, "films", films)
dbWriteTable(con, "people", people)
dbWriteTable(con, "reviews", reviews)
dbWriteTable(con, "roles", roles)

# List database tables
dbListTables(con)
```

#### COUNT & DISTINCT

**COUNT**

-   Counts the number of records with a value in a field

    -   `COUNT(field_name)` counts values in a field, multiple fields: separate by `,`

    -   `COUNT(*)` counts records in a table: total observation

-   Use an `AS` for clarity

-   Includes duplicates

**DISTINCT**

-   `DISTINCT` removes duplicates to return only unique values

-   Combine `COUNT()` with `DISTINCT` to count unique values

```{sql}
-- Count the number of records in the people table
SELECT COUNT(*) AS count_records
FROM people;
```

```{sql}
-- Count the number of birthdates in the people table
SELECT COUNT(birthdate) AS count_birthdate
FROM people;
```

```{sql}
-- Count the records for languages and countries represented in the films table
SELECT COUNT(language) AS count_languages, COUNT(country) AS count_countries
FROM films;
```

**SELECT DISTINCT**

```{sql}
-- Return the unique countries from the films table
SELECT DISTINCT country
FROM films;
```

```{sql}
-- Count the distinct countries from the films table
SELECT COUNT(DISTINCT country) AS count_distinct_countries
FROM films
```

### Query execution

**Order of execution**

-   SQL is not processed in its written order

    -   e.g., SQL needs to know where to `SELECT` data `FROM` before it can `LIMIT` the results.

-   Good to know processing order for debugging and aliasing

**Most common errors**

-   Misspelling

-   Incorrect capitalization

-   Incorrect or missing punctuation, especially commas

### SQL style

[Holywell's style guide](https://www.sqlstyle.guide/)

Other notices:

-   Semicolon `;`

    -   Indicates the end of a query

    -   Easier to translate between SQL flavors

-   Dealing with non-standard field names

    -   Put non-standard field names in double-quotes: `"release year"`

        `SELECT title, "release year", country`

## Filtering Records

### Filtering numbers

**WHERE**

-   Comparison operators

    -   `>` Greater than or after

    -   `<` Less than or before

    -   `=` Equal to

    -   `>=` Greater than or equal to

    -   `<=` Less than or equal to

    -   `<>` Not equal to üëà

-   `WHERE` with strings

    -   Use single-quotes around strings we want to filter: `WHERE country = 'Japan'`

#### WHERE

**Using WHERE with numbers**

In this case, you'll want to filter your data to a specific `budget` range.

```{sql}
-- Select film_ids and imdb_score with an imdb_score over 7.0
SELECT film_id, imdb_score
FROM reviews
WHERE imdb_score > 7;
```

```{sql}
-- Select imdb_score with an imdb_score over 7.0
SELECT COUNT(imdb_score)
FROM reviews
WHERE imdb_score > 7;
```

```{sql}
-- Select film_ids and facebook_likes for ten records with less than 1000 likes
SELECT film_id, facebook_likes
FROM reviews
WHERE facebook_likes < 1000
LIMIT 10;
```

```{sql}
-- Count the records with at least 100,000 votes
SELECT COUNT(num_votes) AS films_over_100K_votes
FROM reviews
WHERE num_votes >= 100000;
```

**Using WHERE with text**

`WHERE` can also filter string values.

```{sql}
-- Count the Spanish-language films
SELECT COUNT(language) AS count_spanish
FROM films
WHERE language = 'Spanish';
```

There are 40 Spanish-language films in this table.

### Multiple criteria

**Multiple criteria**

-   `OR` , `AND` , `BETWEEN`

``` sql
-- OR
SELECT *
FROM coats
WHERE color = 'yellow' OR length = 'short';

-- AND
SELECT *
FROM coats
WHERE color = 'yellow' AND length = 'short';

-- BETWEEN, AND: BETWEEN ‰∏ä‰∏ãÁïåÈÉΩÂåÖÂê´(1,5‰πüÁÆó) üëà
SELECT *
FROM coats
WHERE buttons BETWEEN 1 AND 5;

-- AND, OR: Enclose individual clauses in parenthesesüëà
SELECT title
FROM films
WHERE (release_year = 1994 OR release_year = 1995)
    AND (certification = 'PG' OR certification = 'R');
    
-- BETWEEN, AND, OR
SELECT title
FROM films
WHERE release_year
    BETWEEN 1994 AND 2000 AND country='UK';
```

#### AND

The following exercises combine `AND` and `OR` with the `WHERE` clause.

Combining conditions with `AND` will prove to be very useful when we want our query to return a specific subset of records.

```{sql}
-- Select the title and release_year for all German-language films released before 2000
SELECT title, release_year
FROM films
WHERE (language = 'German')
    AND (release_year < 2000);
```

```{sql}
-- Update the query to see all German-language films released after 2000
SELECT title, release_year
FROM films
WHERE (release_year > 2000)
	AND (language = 'German');
```

Select all details for German-language films released after 2000 but before 2010 using only `WHERE` and `AND`.

```{sql}
-- Select all records for German-language films released after 2000 and before 2010
SELECT *
FROM films
WHERE (language = 'German')
    AND (release_year > 2000 AND release_year < 2010);
```

#### OR

This time you'll write a query to get the `title` and `release_year` of `films` released in 1990 or 1999, which were in English or Spanish and took in more than \$2,000,000 `gross`.

```{sql}
-- Find the title and year of films from the 1990 or 1999
SELECT title, release_year
FROM films
WHERE (release_year = 1990 OR release_year = 1999)
    -- Add a filter to see only English or Spanish-language films
	AND (language = 'English' OR language = 'Spanish')
	-- Filter films with more than $2,000,000 gross
	AND (gross > 2000000);
```

#### BETWEEN

Let's use `BETWEEN` with `AND` on the `films` database to get the `title` and `release_year` of all Spanish-language films released between 1990 and 2000 (inclusive) with `budgets` over \$100 million.

```{sql}
-- Select the title and release_year for films released between 1990 and 2000
SELECT title, release_year
FROM films
WHERE (release_year BETWEEN 1990 AND 2000)
    -- Narrow down your query to films with budgets > $100 million
	AND (budget > 100000000)
	-- Restrict the query to only Spanish-language films
	AND (language = 'Spanish');
```

```{sql}
SELECT title, release_year
FROM films
WHERE release_year BETWEEN 1990 AND 2000
	AND budget > 100000000
    -- Amend the query to include Spanish or French-language films
	AND (language = 'Spanish' OR language = 'French');
```

### Filtering text

Filter a pattern rather than specific text.

-   `LIKE`

    eg., `WHERE name LIKE '%r'`, `WHERE name LIKE '___t%'`

-   `NOT LIKE`

    eg., `WHERE name NOT LIKE 'A.%'`

-   `IN`

    eg., `WHERE release_year IN (1920, 1930, 1940)`,

    `WHERE country IN ('Germany', 'France')`

Pattern

-   `%` match zero, one, or many characters

-   `_` match a single character

#### LIKE & NOT LIKE

The `LIKE` and `NOT LIKE` operators can be used to find records that either match or do not match a specified pattern, respectively. They can be coupled with the wildcards `%` and `_`.

This is useful when you want to filter text, but not to an exact word.

```{sql}
-- Select the names that start with B
SELECT name
FROM people
WHERE name LIKE 'B%';
```

```{sql}
SELECT name
FROM people
-- Select the names that have r as the second letter
WHERE name LIKE '_r%'
```

```{sql}
SELECT name
FROM people
-- Select names that don't start with A
WHERE name NOT LIKE 'A%'
```

```{sql}
SELECT COUNT(name) AS count_name_beginA
FROM people
-- Select names that don't start with A
WHERE name NOT LIKE 'A%'
```

#### WHERE IN

You can query multiple conditions using the `IN` operator and a set of parentheses. It is a valuable piece of code that helps us keep our queries clean and concise.

```{sql}
-- Find the title and release_year for all films over two hours in length released in 1990 and 2000
SELECT title, release_year
FROM films
WHERE (duration > 120)
    AND (release_year IN (1990, 2000));
```

```{sql}
-- Find the title and language of all films in English, Spanish, and French
SELECT title, language
FROM films
WHERE language IN ('English', 'Spanish', 'French');
```

```{sql}
-- Find the title, certification, and language all films certified NC-17 or R that are in English, Italian, or Greek
SELECT title, certification, language
FROM films
WHERE (certification IN ('NC-17', 'R'))
    AND (language IN ('English', 'Italian', 'Greek'));
```

#### Combine filtering & selecting

How many 90's films we have in our dataset that would be suitable for English-speaking teens?

(You will be using `DISTINCT` here too because, surprise, there are two movies named 'Hamlet' in this dataset.)

```{sql}
-- Count the unique titles
SELECT COUNT(DISTINCT title) AS nineties_english_films_for_teens
FROM films
-- Filter to release_years to between 1990 and 1999
WHERE (release_year BETWEEN 1990 AND 1999)
-- Filter to English-language films
	AND (language = 'English')
-- Narrow it down to G, PG, and PG-13 certifications
	AND (certification IN ('G', 'PG', 'PG-13'));
```

### NULL values

`null` : Missing values

-   `COUNT(field_name)` includes only non-missing values

-   `COUNT(*)` includes missing values

Use `IS NULL` or `IS NOT NULL` to:

-   Identify missing values

-   Select missing values

-   Exclude missing values

```{sql}
-- List all film titles with missing budgets
SELECT title AS no_budget_info
FROM films
WHERE budget IS NULL 
```

```{sql}
-- Count the number of films we have language data for
SELECT COUNT(title) AS count_language_known
FROM films
WHERE language IS NOT NULL;
```

## Aggregate Functions

### Summarizing data

**Aggregate functions**

`AVG()` , `SUM()` , `MIN()` , `MAX()` , `COUNT()`

-   Numerical fields only

    -   `AVG()`, `SUM()`

-   Various data types

    -   `MIN()` , `MAX()` , `COUNT()`

    -   MIN() \<-\> MAX() in non-numerical data

        -   A \<-\> Z

        -   1715 \<-\> 2022

-   Aliasing when summarizing

Perhaps you'd like to know how old the oldest film in the films table is, what the most expensive film is, or how many films you have listed.

```{sql}
-- Query the sum of film durations
SELECT SUM(duration) AS total_duration
FROM films;
```

```{sql}
-- Calculate the average duration of all films
SELECT AVG(duration) AS average_duration
FROM films;
```

```{sql}
-- Find the latest release_year
SELECT MAX(release_year) AS latest_year
FROM films;
```

```{sql}
-- Find the duration of the shortest film
SELECT MIN(duration) AS shortest_film
FROM films;
```

### Summarizing subsets

-   Using `WHERE` with aggregate functions

-   `ROUND()` : Round a number to a specified decimal

    -   `ROUND(number_to_round, decimal_places)`

    -   whole number: `ROUND(number_to_round, 0)`

    -   Â∞èÊï∏ÈªûÁ¨¨‰∫å‰Ωç: `ROUND(number_to_round, 2)`

    -   to thousands: `ROUND(number_to_round, -3)`

        -   123456 ‚ü∂ 12000, negative parameter

#### Aggregate functions & WHERE

In your film-industry role, as an example, you may like to summarize each certification category to compare how they each perform or if one certification has a higher average budget than another.

```{sql}
-- Calculate the sum of gross from the year 2000 or later
SELECT SUM(gross) AS total_gross
FROM films
WHERE release_year >= 2000;
```

```{sql}
-- Calculate the average gross of films that start with A
SELECT AVG(gross) AS avg_gross_A
FROM films
WHERE title LIKE 'A%';
```

```{sql}
-- Calculate the lowest gross film in 1994
SELECT MIN(gross) AS lowest_gross
FROM films
WHERE release_year = 1994;
```

```{sql}
-- Calculate the highest gross film released between 2000-2012
SELECT MAX(gross) AS highest_gross
FROM films
WHERE release_year BETWEEN 2000 AND 2012;
```

#### ROUND()

Aggregate functions work great with numerical values; however, these results can sometimes get unwieldy when dealing with long decimal values. SQL provides you with the `ROUND()` function to tame these long decimals.

```{sql}
-- Round the average number of facebook_likes to one decimal place
SELECT ROUND(AVG(facebook_likes), 1) AS avg_facebook_likes
FROM reviews;
```

A useful thing you can do with `ROUND()` is have a negative number as the decimal place parameter. This can come in handy if your manager only needs to know the average number of `facebook_likes` to the hundreds since granularity below one hundred likes won't impact decision making.

```{sql}
-- Calculate the average budget rounded to the thousands, 39902000
SELECT ROUND(AVG(budget), -3) AS avg_budget_thousands
FROM films;
```

The `ROUND()` function is very handy when making financial calculations to get a top-level view or specify to the penny or cent.

### Aliasing and arithmetic

**Arithmetic**

`+` , `-` , `*` , and `/`

-   When dividing, SQL assumes that we want to get an integer back if we divide an integer by an integer.We can add decimal places to our numbers if we want more precision

    -   `SELECT (4 / 3);` ‚ü∂ 1

    -   `SELECT (4.0 / 3.0);` ‚ü∂ 1.333...

-   Aliasing with arithmetic & function

**Aggregate functions vs. arithmetic**

-   aggregate functions: perform their operations on the fields vertically

-   arithmetic: adds up the records horizontally

```{sql}
-- default
SELECT (2 / 10);
```

```{sql}
-- add decimal
SELECT (2.0 / 10.0);
```

#### Aliasing with functions

Aliasing can be a lifesaver, especially as we start to do more complex SQL queries with multiple criteria. Aliases help you keep your code clean and readable.

For example, if you want to find the `MAX()` value of several fields without aliasing, you'll end up with the result with several columns called `max` and no idea which is which. You can fix this with aliasing.

```{sql}
-- Calculate the title and duration_hours from films
SELECT title, (duration / 60.0) AS duration_hours
FROM films;
```

```{sql}
-- Calculate the percentage of people who are no longer alive
SELECT COUNT(deathdate) * 100.0 / COUNT(*) AS percentage_dead
FROM people;
```

```{sql}
-- Find the number of decades in the films table
SELECT (MAX(release_year) - MIN(release_year)) / 10.0 AS number_of_decades
FROM films;
```

`films` table covers films released over one hundred years!

#### Rounding results

In the previous exercise, many of the results were inconveniently long. Update the query by adding ROUND()\` around the calculation.

```{sql}
-- Round duration_hours to two decimal places
SELECT title, ROUND((duration / 60.0), 2) AS duration_hours
FROM films;
```

## Sorting and Grouping

### Sorting results

`ORDER BY` : `ASC`, `DESC`

-   Text `ASC` : Alphabetically (A-Z)

-   ORDER BY multiple fields: `ORDER BY field_one, field_two`

-   Different orders: `ORDER BY birthdate, name DESC;`

#### ORDER BY

**Sorting single fields**

```{sql}
-- Select name from people and sort alphabetically
SELECT name
FROM people
ORDER BY name ASC;
```

```{sql}
-- Select the title and duration from longest to shortest film
SELECT title, duration
FROM films
ORDER BY duration DESC;
```

**Sorting multiple fields**

It will sort by the first field specified, then sort by the next, and so on.

```{sql}
-- Select the release year, duration, and title sorted by release year and duration
SELECT release_year, duration, title
FROM films
WHERE release_year IS NOT NULL
ORDER BY release_year, duration;
```

```{sql}
-- Select the certification, release year, and title sorted by certification and release year
-- Ordered first by certification (alphabetically) and second by release year, starting with the most recent year
SELECT certification, release_year, title
FROM films
WHERE certification IS NOT NULL
ORDER BY certification ASC, release_year DESC;
```

### Grouping data

#### GROUP BY

-   `GROUP BY` multiple fields: `GROUP BY certification, language`

**GROUP BY single fields**

```{sql}
-- Find the release_year and film_count of each year
SELECT release_year, COUNT(*) AS film_count
FROM films
WHERE release_year IS NOT NULL
GROUP BY release_year;
```

```{sql}
-- Find the release_year and average duration of films for each year
SELECT release_year, AVG(duration) AS avg_duration
FROM films
WHERE release_year IS NOT NULL
GROUP BY release_year;
```

Using GROUP BY with a time or date field such as `release_year` can help us identify trends such as a period of time where movies were really short!

**GROUP BY multiple fields**

Look at the maximum budget for each country in each year

```{sql}
-- Find the release_year, country, and max_budget, then group and order by release_year and country
SELECT release_year, country, MAX(budget) AS max_budget
FROM films
WHERE release_year IS NOT NULL
GROUP BY release_year, country
ORDER BY release_year, country;
```

**Answering business questions**

Which `release_year` had the most language diversity?

```{sql}
SELECT release_year, COUNT(DISTINCT language) AS num_language
FROM films
GROUP BY release_year
ORDER BY num_language DESC;
```

### Filtering grouped data

**HAVING vs WHERE**

+-------------------------------------------------------------+--------------------------------------------+
| HAVING                                                      | WHERE                                      |
+=============================================================+============================================+
| HAVING filters *grouped* records                            | WHERE filters *individual* records         |
+-------------------------------------------------------------+--------------------------------------------+
| In what years was the average film duration over two hours? | What films were released in the year 2000? |
+-------------------------------------------------------------+--------------------------------------------+
| ``` sql                                                     | ``` sql                                    |
| SELECT release_year                                         | SELECT title                               |
| FROM films                                                  | FROM films                                 |
| GROUP BY release_year                                       | WHERE release_year = 2000;                 |
| HAVING AVG(duration) > 120;                                 | ```                                        |
| ```                                                         |                                            |
+-------------------------------------------------------------+--------------------------------------------+

#### HAVING

Filtering grouped data can be especially handy when working with a large dataset. When working with thousands or even millions of rows, `HAVING` will allow you to filter for just the group of data you want

Find out which countries (or country) have the most varied film certifications.

```{sql}
-- Select the country and distinct count of certification as certification_count
SELECT country, COUNT(DISTINCT certification) AS certification_count
FROM films
-- Group by country
GROUP BY country
-- Filter results to countries with more than 10 different certifications
HAVING COUNT(DISTINCT certification) > 10;
```

#### HAVING and sorting

Writing a query showing what countries have the highest average film budgets.

```{sql}
-- Select the country and average_budget from films
SELECT country, AVG(budget) AS average_budget
FROM films
-- Group by country
GROUP BY country
-- Filter to countries with an average_budget of more than one billion
HAVING AVG(budget) > 1000000000
-- Order by descending order of the aggregated budget
ORDER BY average_budget DESC;
```

South Korea and Hungary seem to have pricey films... or do they? Actually, these budgets are pretty standard for their local currency.

#### All together

You'll write a query that returns the average budget and gross earnings for films each year after 1990 if the average budget is greater than 60 million.


```{sql}
-- Select the release_year, average budget and average gross
-- for films released after 1990 grouped by year
SELECT release_year, AVG(budget) AS avg_budget, AVG(gross) AS avg_gross
FROM films
WHERE release_year > 1990
GROUP BY release_year
-- Only years with an avg_budget of more than 60 million
HAVING AVG(budget) > 60000000
-- Order the results from highest to lowest average gross and limit to one
ORDER BY avg_gross DESC
LIMIT 1;
```

```{r}
# disconnect the sql connection
dbDisconnect(con)
```
