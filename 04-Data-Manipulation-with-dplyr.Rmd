# Data Manipulation

## Transforming Data

### Exploring data

Useful verbs:

-   `glimpse()`: similar to `str()`.

-   `select()`: select columns. `select(var_name1, var_name2,...)`

-   `filter()`: select rows. For multiple conditions, can separate by:

    1\. comma `filter(con1, con2,...)`

    2\. logic operator `&` or `|`, `filter(con1 & con2)`

    3.`%in%` : used to filter for multiple values. `filter(var %in% c("var_value1", "var_value2"))`

-   `arrange()`: sort by variables.

-   `mutate()`: change exist or create new variables.

```{r}
library(tidyverse)

counties <- read_csv("data/counties.csv")
```

```{r}
glimpse(counties)
```

```{r}
counties %>%
  # Select the five columns 
  select(state, county, population, men, women) %>%
  # Add the proportion_men variable
  mutate(proportion_men = men / population) %>%
  # Filter for population of at least 10,000
  filter(population >= 10000, state == "California") %>%
  # Arrange proportion of men in descending order 
  arrange(desc(proportion_men))
```

## Aggregating Data

### Count

One way we can aggregate data is to `count()`: to find out the number of observations.

Count variable and sort:

``` r
count(var, sort = TRUE)
```

```{r}
counties_selected <- counties %>%
    select(county, region, state, population, citizens)

# Use count to find the number of counties in each region
counties_selected %>%
    count(region, sort = TRUE)
```

Add weight:

``` r
count(var1, wt = var2, sort = TRUE)
```

```{r}
counties_selected <- counties %>%
    select(county, region, state, population, citizens)

# Find number of counties per state, weighted by citizens, sorted in descending order
counties_selected %>%
    count(state, wt = citizens, sort = TRUE)
```

Mutating and counting:

"What are the US states where the most people walk to work?"

```{r}
counties_selected <- counties %>%
    select(county, region, state, population, walk)

counties_selected %>%
  # Add population_walk containing the total number of people who walk to work 
  mutate(population_walk = walk * population / 100) %>%
  # Count weighted by the new column, sort in descending order
  count(state, wt = population_walk, sort = TRUE)
```

### group_by, summarize, ungroup

-   `summarize()`: takes many observations and turns them into one observation. Also can define multiple variables in a `summarize` call.

-   `group_by()`: aggregate within groups. We can group by multiple columns by passing multiple column names to `group_by`.

    When you group by multiple columns and then summarize, it's important to remember that the summarize "peels off" one of the groups, but leaves the rest on. For example, if you `group_by(X, Y)` then summarize, the result will still be grouped by `X`.

-   `ungroup()`: If you don't want to keep variable as a group, you can add another `ungroup()`.

Summarize both population and land area by state, with the purpose of finding the density (in people per square miles).

```{r}
counties %>%
    select(state, county, population, land_area) %>%
    # Group by state 
    group_by(state) %>%
    # Find the total area and population
    summarize(total_area = sum(land_area),
              total_population = sum(population)) %>%
    # Add a density column
    mutate(density = total_population / total_area) %>%
    # Sort by density in descending order
    arrange(desc(density))
```

You can group by multiple columns instead of grouping by one.Summarizing by state and region:

```{r}
counties %>%
    select(region, state, county, population) %>%
    # Group and summarize to find the total population
    group_by(region, state) %>%
    summarize(total_pop = sum(population)) %>%
    # Calculate the average_pop and median_pop columns 
    summarize(average_pop = mean(total_pop),
              median_pop = median(total_pop))
```

### slice_min, slice_max

`slice_max()` operates on a grouped table, and returns the largest observations in each group. The function takes two arguments: the column we want to base the ordering on, and the number of observations to extract from each group, specified with the `n` argument.

``` r
# The largest observations
slice_max(var, n = 1) 

# The 3 largest observations
slice_max(var, n = 3)
```

Similarly, `slice_min()` returns the smallest observations in each group.

``` r
# The smallest observations
slice_min(var, n = 1) 

# The 3 smallest observations
slice_min(var, n = 3)
```

The `slicing` are often used when creating visualizations, where we may want to highlight the extreme observations on the plot.

Q: In how many states do more people live in metro areas than non-metro areas?

```{r}
counties %>%
    select(state, metro, population) %>%
    # Find the total population for each combination of state and metro
    group_by(state, metro) %>%
    summarize(total_pop = sum(population)) %>%
    # Extract the most populated row for each state
    slice_max(total_pop, n = 1) %>%
    # Count the states with more people in Metro or Nonmetro areas
    ungroup() %>%
    count(metro, sort = TRUE)
```

## Selecting and Transforming Data

### Select

#### Range

Select a range of columns.

``` r
select(var1, var3:var6)

# For example
select(state, county, drive:work_at_home)
```

```{r}
counties %>%
  # Select state, county, population, and industry-related columns
  select(state, county, population, professional:production) %>%
  # Arrange service in descending order 
  arrange(desc(service))
```

#### Contains

Specify criteria for choosing columns.

``` r
select(var1, var3, contains("char"))

# For example
select(state, county, contains("work"))
```

#### Starts with

To select only the columns that start with a particular prefix.

``` r
select(var1, var3, starts_with("char"))

# For example
select(state, county, starts_with("income"))
```

#### Ends with

Finds columns ending in a string.

``` r
select(var1, var3, ends_with("char"))

# For example
select(state, county, ends_with("tion"))
```

```{r}
counties %>%
  # Select the state, county, population, and those ending with "work"
  select(state, county, population, ends_with("work")) %>%
  # Filter for counties that have at least 50% of people engaged in public work
  filter(public_work > 50)
```

#### Last column

`last_col()` grabs the last column.

#### Matches

Selects columns that have a specified pattern.

``` r
select(matches("regex"))

# For example
select(matches(".\_."))
```

#### Removing a variable

We can use select to remove variables from a table by adding a `-` in front of the column name to remove.

``` r
select(-(var1))

# For example
select(-census_id)
```

### Rename

Often, rather than only selecting columns, we'll sometimes want to rename the ones we already have.

Compare these two ways:

-   Select

When select variables, change variables' name at the same time.

``` r
select(var1, var2, var_newname = var_oldname)

# For example
counties %>%
    select(state, county, population, unemployment_rate = unemployment)
```

```{r}
counties %>%
    # Select state, county, and poverty as poverty_rate
    select(state, county, poverty_rate = poverty)
```

-   Rename

`rename()` is often useful for changing the name of a column that comes out of another verb.

``` r
rename(var_newname = var_oldname)

# For example
counties %>%
    select(state, county, population, unemployment) %>%
    rename(unemployment_rate = unemployment)
```

```{r}
counties %>%
    # Count the number of counties in each state
    count(state)
```

```{r}
counties %>%
    # Count the number of counties in each state
    count(state) %>%
    # Rename the n column to num_counties
    rename(num_counties = n)
```

### Transmute

Transmute is like a combination of select and mutate: it returns a subset of the columns like select, but it can also transform and change the columns, like mutate, at the same time.

It control which variables you keep, which variables you calculate, and which variables you drop.

``` r
transmute(var1, var2, var_new = var_old*do caculate)

#For example
counties %>%
    transmute(state, county, fraction_men = men / population)
```

```{r}
counties %>%
    # Keep the state, county, and populations columns, and add a density column
    transmute(state, county, population, density = population/land_area) %>%
    # Filter for counties with a population greater than one million 
    filter(population > 1000000) %>%
    # Sort density in ascending order 
    arrange(density)
```

**Summary**

![](image/4-3-3.summary%20table.png){width="515"}

``` r
# Change the name of the unemployment column
counties %>%
  rename(unemployment_rate = unemployment)

# Keep the state and county columns, and the columns containing poverty
counties %>%
  select(state, county, contains("poverty"))

# Calculate the fraction_women column without dropping the other columns
counties %>%
  mutate(fraction_women = women / population)

# Keep only the state, county, and employment_rate columns
counties %>%
  transmute(state, county, employment_rate = employed / population)
```

## Case Study: The babynames Dataset

### Load dataset

```{r}
library(babynames)

babynames
```

### Exploring data

**Filtering and arranging for one year**

```{r}
babynames %>%
    # Filter for the year 1990
    filter(year == 1990) %>%
    # Sort the number column in descending order 
    arrange(desc(n))
```

**Finding the most popular names each year**

```{r}
babynames %>%
    # Find the most common name in each year
    group_by(year) %>%
    slice_max(n, n = 1)
```

**Visualizing names with ggplot2**

```{r}
selected_names <- babynames %>%
    # Filter for the names Steven, Thomas, and Matthew. And female only 
    filter(name %in% c("Steven", "Thomas", "Matthew") & sex == "F")

# Plot the names using a different color for each name
ggplot(selected_names, aes(x = year, y = n, color = name)) +
    geom_line()
```

**Finding the year each name is most common**

```{r}
# Calculate the fraction of people born each year with the same name
babynames %>%
  group_by(year) %>%
  mutate(year_total = sum(n)) %>%
  ungroup() %>%
  mutate(fraction = n / year_total) %>%
  # Find the year each name is most common
  group_by(name) %>%
  slice_max(fraction, n = 1)
```

**Adding the total and maximum for each name**

You'll divide each name by the maximum for that name. This means that every name will peak at 1.

```{r}
babynames %>%
  # Add columns name_total and name_max for each name
  group_by(name) %>%
  mutate(name_total = sum(n),
         name_max = max(n)) %>%
  # Ungroup the table 
  ungroup() %>%
  # Add the fraction_max column containing the number by the name maximum 
  mutate(fraction_max = n / name_max)
```

**Visualizing the normalized change in popularity**

You picked a few names and calculated each of them as a fraction of their peak. This is a type of *"normalizing"* a name, where you're focused on the relative change within each name rather than the overall popularity of the name.

```{r}
names_normalized <- babynames %>%
    group_by(name) %>%
    mutate(name_total = sum(n),
           name_max = max(n)) %>%
    ungroup() %>%
    mutate(fraction_max = n / name_max)

names_filtered <- names_normalized %>%
    # Filter for the names Steven, Thomas, and Matthew. And male only
    filter(name %in% c("Steven", "Thomas", "Matthew") & sex == "M")

# Visualize these names over time
ggplot(names_filtered, aes(x = year, y = fraction_max, color = name)) +
    geom_line()
```

As you can see, *the line for each name hits a peak at 1*, although the peak year differs for each name.

**Using ratios to describe the frequency of a name**

Window function: `lag()`

``` r
v <- c(1, 3, 6, 14); v
## 1 3 6 14

lag(v)
## NA 1 3 6

v - lag(v)
## NA 2 3 8
```

Notice that the first observation for each name is missing a ratio, since there is no previous year.

```{r}
babynames_fraction <- babynames %>%
    group_by(year) %>%
    mutate(year_total = sum(n)) %>%
    ungroup() %>%
    mutate(fraction = n / year_total)

babynames_fraction %>%
    # Arrange the data in order of name, then year 
    arrange(name, year) %>%
    # Group the data by name
    group_by(name) %>%
    # Add a ratio column that contains the ratio of fraction between each year 
    mutate(ratio = fraction / lag(fraction))
```

**Biggest jumps in a name**

To look further into the names that experienced the biggest jumps in popularity in consecutive years.

```{r}
babynames_ratios_filtered <- babynames_fraction %>%
    arrange(name, year) %>%
    group_by(name) %>%
    mutate(ratio = fraction / lag(fraction)) %>%
    filter(fraction >= 0.00001)

babynames_ratios_filtered %>%
    # Extract the largest ratio from each name 
    slice_max(ratio, n = 1) %>%
    # Sort the ratio column in descending order 
    arrange(desc(ratio)) %>%
    # Filter for fractions greater than or equal to 0.001
    filter(fraction >= 0.001)
```
